---
title: "How to read, write and rename files using Node.js scripts"
date: 2021-01-16
tags: ["nodejs"]
emoji: 💿
coverImage: 'https://images.unsplash.com/photo-1610721578236-12a1a8de20b4?ixid=MXwxMjA3fDB8MHxlZGl0b3JpYWwtZmVlZHwyOXx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=900&q=60'
---

Node.js scripts can be a real time-saver when you want to automate the process of modifying and renaming files. I use them to convert posts I’ve written in my text editor into a MDX format for my [blog](https://www.emgoto.com/).

In this post I’ll be covering the things you need to know to write your own Node.js scripts for reading and writing files (using [fs](https://nodejs.dev/learn/the-nodejs-fs-module) and [replace-in-file](https://www.npmjs.com/package/replace-in-file)). We’ll also be touching on how to unit tests your scripts with [mock-fs](https://github.com/tschaub/mock-fs).

## Creating and running your npm script
The scripts I write live inside of the `scripts` folder in my blog's [repository](https://github.com/emgoto/emgoto.com/blob/master/scripts).

```js:title=scripts/modifyFile.js
#!/usr/bin/env node

const main = () => {
    // do stuff
}

main();
```

> The first line is a **shebang line** to declare that the script executes using Node.js

I declare my script in my repository’s `package.json` file:

```json:title=package.json
"scripts": {
    "modify": "./scripts/modifyFile.js"
},
```

These scripts are also known as **npm scripts**.

Depending on whether you’re using Yarn or npm, you can run this script with one of these commands: 

```bash
yarn modify
# or
npm run modify
```

## Make sure to install dependencies
In each of the sections below, we’ll be making use of libraries like `glob`, `path` and `fs`. Make sure to install these dependencies before you start trying to use them!

Since these are only used in a script, you can install them as a `devDependency`:

```bash
yarn add --dev glob path fs
# or
npm install -D glob path fs
```

## Passing in arguments into the script
Oftentimes, you might want to pass in an argument to your script, like the name of the file you wish to modify.

You can pass in as many arguments as you like:

```bash
yarn modify argOne argTwo
# or
npm run modify argOne argTwo
```

And then you can get them out using the `process.argv` array: 

```js
process.argv[2] // argOne
process.argv[3] // argTwo
```

(The 0th and 1st spots in the array contain `node` and `modify` respectively).

## How to find a specific file with glob

Let’s say you were looking for any zip files inside of your app’s `src` folder:

```js
const { join } = require('path');
const glob = require('glob');

const files = glob.sync(
    join(process.cwd(), 'src', '**', '*.zip'),
);
```

Breaking down the code above:
* `process.cwd()` gets the current directory (from where you ran the script)
* `join()` will join all the strings you pass in with `/` to make a path
* `glob.sync()` does a pattern-matching search to try and find any files that match the string you provided

This will return an array of files that end in `.zip`. If you were only expecting one file, you’ll be able to grab it from the 0th index of the array (`files[0]`).

## How to rename a file with fs rename
The file system (fs) module provides a lot of useful functions for modifying your files. The first one we’ll be looking at is `rename`.

This will **asynchronously** rename a file:

```js
const { rename } = require('fs');

const callback = () => {};

const oldFileName = '/Users/emma/src/emgoto.com/old.txt';
const newFileName = '/Users/emma/src/emgoto.com/new.txt';

rename(oldFileName, newFileName, callback);
```

The file names need to contain the full path of the file. Remember that we can use `process.cwd()` to get the file path of the current directory.

So instead of this:

```js
'/Users/emma/src/emgoto.com/old.txt'
```

We can do this:

```js
`${process.cwd()}/old.txt`
```

You’ll also notice that we’re passing in a callback function as the third argument. This callback will get executed once the rename was successful.

> Even if you don’t want a callback executed, this argument is not optional. You can pass in `() => {}` if you don’t want anything to happen.

Alternatively, you can also synchronously rename a file using `renameSync`:

```js
const { renameSync } = require('fs');

renameSync(oldFileName, newFileName);
```

This means while the file is being renamed, the rest of the script won't execute.

### Synchronous vs asynchronous - which should I use?

If you’re writing a long script that does a lot of modifications, it may be quicker to use the asynchronous methods as opposed to doing it synchronously. In my case, since the scripts I write are simple, it doesn’t make too much of a difference.

The main thing to keep in mind is that, if you are renaming a file **asynchronously** and then directly after you try and modify the new file:

```js
rename(oldFileName, newFileName, callback); // <- async
doStuff(newFileName);
```

You may run into issues if the `rename` function hasn’t finished yet, and you're executing `doStuff` on a file that doesn’t exist yet.

In this scenario, make sure to either do it synchronously with `renameSync`, or make sure you modify the new file inside of the fallback:

```js
renameSync(oldFileName, newFileName);
doStuff(newFileName);

// or

const callback = () => doStuff(newFileName);
rename(oldFileName, newFileName, callback);
```

## How to rename a folder with fs rename
You can also use `rename` and `renameSync` to rename folders. However, this will error out if you try and rename a folder to a name that already exists.

## How to delete a file with fs unlink
You can delete a file using `unlink`:

```js
const { unlink } = require('fs');

unlink(fileToDelete, callback);
```

Similar to renaming, unlink is asynchronous, and has a sync alternative, `unlinkSync`:

```js
const { unlinkSync } = require('fs');

unlinkSync(fileToDelete);
```

## How to deleting a folder with fs rmdir
You can delete a whole folder with `rmdir`:

```js
const { rmdir } = require('fs');

rmdir(folderToDelete, callback);
```

The sync version:

```js
const { rmdirSync } = require('fs');

rmdirSync(folderToDelete);
```

## Modifying your file’s contents
When I’m converting my posts from Markdown to MDX, there are a number of changes I want to make. For instance, my text editor will format the title of my post like this:

```md
# Hello world
```

But I want my title stored in a frontmatter format like this:

```md
---
title: Hello world
---
```

There’s two options that I’ve found for file modification.

### Read and writing to a file using fs readFile and writeFile
We can make use of the fs module to modify files with `readFile` and `writeFile` (they also have sync versions!). Firstly, we’ll need to read the file into a variable:

```js
const { readFileSync } = require('fs');

const content = readFileSync(file, 'utf8');
```

Then we can make use of JavaScript’s [replace](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace) function to modify the file as required. If we wanted to replace all instances of `Hello` with `Goodbye`, for example:

```js
const newContent = content.replace('Hello', 'Goodbye');
```

As well as using a string like "Hello" to match on text, we can make use of Regex as well. The Regex to match on our `# Hello world` heading would look like this:

```js
/^# .*/g
```

If you're rusty on your Regex (or haven’t used it before):

* Your Regex pattern lives inside of `//g`. We have the letter g on the end to make it “global”, which means it will find all occurrences.
* `^#` is saying _“find a line that starts with a #”_
* `.` matches any character, and `.*` will match an infinite number of characters (i.e. the rest of the line).

> I recommend using a tool like [RegExr](https://regexr.com/) to test that your Regex is returning what you would expect it to.

Once we’ve found the header line we’re looking for, we’ll also need a function to convert that header into frontmatter.

Our `toFrontMatter` function will take in the line as an argument, and transform it: 

```js
const toFrontMatter = (line) => {
	const title = line.replace('# ', '').trim();
	
	return `---
title: ${title}
---
`;
}
```

To bring it all together:

```js
const { readFileSync, writeFileSync } = require('fs');

// Read the file
const content = readFileSync(file, 'utf8');

// Get the contents, and update them
const newContent = content.replace(/^# .*/g, toFrontMatter);

// Update the file
writeFileSync(file, newContent, 'utf8');
```


### Using replace-in-file to modify a file
Alternatively, there’s also a library we can use called [replace-in-file](https://www.npmjs.com/package/replace-in-file) to modify files:

```js
const replace = require('replace-in-file');

const options = {
    files: fileName,
    from: 'Hello',
    to: 'World',
};

replace(options);
```

> replace is async. You can also use the synchronous `replace.async`.

To achieve the same result as what we did in the previous section with JavaScript’s `replace(), we would do the following:

```js
const options = {
    files: fileName,
    from: /^# .*/g,
    to: toFrontMatter,
};
```

replace-in-file also lets you do this on more than one file at a time:

```js
const options = {
    files: [fileName, anotherFileName], // highlight-line
    from: /^# .*/g,
    to: toFrontMatter,
}
```

Your `from` and `to` values can also be arrays:

```js
const options = {
    files: [fileName, anotherFileName, anotherFileName],
    from: [/^# .*/g, anotherRegex], // highlight-line
    to: [toFrontMatter, anotherFunction], // highlight-line
}
```

When you're using arrays with `to` and `from`:

* The `from` in the 0th position will convert to the `to` in the 0th position
* The `from` in the 1st position will convert to the `to` in the 1st position

And so on!


## Unit testing your Node.js scripts with mock-fs

Unit tests are a great way to force yourself to write maintainable code. There is a library called [mock-fs](https://github.com/tschaub/mock-fs) we can use to mock out folders and files.

You'll remember that at the beginning, our script was set up to look like this:

```js
const main = () => { 
    // ...
}

main();
```

We'll need to wait until the script has finished before we write our unit tests. To do this, we can make our main function async, and export it:

```js:title=scripts/modifyFile.js
const main = async () => { //highlight-line
    const options = {
        files: `${process.cwd()}/folderName/index.md`,
	    from: /^# .*/g,
	    to: toFrontMatter
    };

    return replace(options); // replace returns a promise
};

export { main }; // highlight-line
```

Now in our unit tests we can await for `main()` to be complete:

```js:title=scripts/modifyFile.test.js
import { main } from './modifyFile';

describe('script', () => {
    test('first test', async () => {
        await main();
        // make assertions once main function has completed
    });
});
```

This also means that you’ll need to update your package.json file to make sure it still works:

```json:title=package.json
"scripts": {
    "modify": "./scripts/modifyFile.js main"
}
```


Before we make any assertions though, we’ll also need to add some mocks.

### Mock your files and folders using mock-fs

We want to be able to mock out some files, because otherwise you would need to have dummy test files that live in your test folder, _and_ you would also need to reset them to their original state at the end of each unit test.

With mock-fs, we can mock out folder structures and the content of files:

```js
import mock from 'mock-fs';
import { main } from './modifyFile';

describe('script', () => {
    beforeAll(() => {
        mock({
            'folderName': {
                'index.md': '# Hello world!',
            },
        });
    });

    afterAll(() => {
        mock.restore();
    });
```

These folder names are relative to the root of your repository. Here we’re mocking a folder/file structure like this:

```js
folderName
    index.md // <- contains "# Hello world!"
```

### Write a unit test on file modification

Now we can continue with our unit test. We can assert on the file's contents:

```js
test('should replace markdown heading with frontmatter', async () => {
	    const expectedResult = `---
title: Hello world
---`;

    await main();

    const file = `${process.cwd()}/folderName/index.md`
    const result = readFileSync(file, 'utf8');

    expect(result).toEqual(expectedResult);
});
```

### Write a unit test on file renaming
In the case where we want to unit test that files were renamed, we can do the following:

```js
test('should successfully move and rename files', async () => {
    const expectedFiles = [
        `${process.cwd()}/folderName/renamedFile.md`,
    ];

    await main();

    const files = glob.sync(`${process.cwd()}/folderName/**`);

    expect(files).toEqual(expectedFiles);
});
```

## Conclusion
Automating the process of file renaming or writing can speed up an otherwise tedious process. With this tutorial, you should now feel comfortable to write your own scripts! By unit testing your scripts with mock-fs, you can also have that certainty that your scripts work as expected.
